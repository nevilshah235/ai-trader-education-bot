# PKCE Implementation for OAuth 2.0

## Overview

This document describes the implementation of PKCE (Proof Key for Code Exchange) in the OAuth 2.0 authentication flow. PKCE is a security extension that prevents authorization code interception attacks.

## What is PKCE?

PKCE (RFC 7636) adds an additional layer of security to the OAuth 2.0 authorization code flow by:

1. **Code Verifier**: A cryptographically random string generated by the client
2. **Code Challenge**: A SHA-256 hash of the code verifier, sent with the authorization request
3. **Verification**: The authorization server verifies that the code verifier matches the code challenge during token exchange

This prevents attackers from intercepting the authorization code and exchanging it for tokens, since they won't have the original code verifier.

## Implementation Details

### 1. PKCE Helper Functions (config.ts)

#### `generateCodeVerifier()`
- Generates a cryptographically secure random string (32 bytes)
- Base64url-encoded (URL-safe, no padding)
- Returns a 43-character string

#### `generateCodeChallenge(verifier)`
- Takes the code verifier as input
- Computes SHA-256 hash of the verifier
- Returns base64url-encoded hash

#### `storeCodeVerifier(verifier)`
- Stores the code verifier in sessionStorage
- Adds timestamp for expiration tracking (10 minutes)

#### `getCodeVerifier()`
- Retrieves the stored code verifier
- Validates it hasn't expired (10 minute timeout)
- Returns null if missing or expired

#### `clearCodeVerifier()`
- Removes code verifier from sessionStorage after successful token exchange

### 2. OAuth URL Generation (config.ts)

The `generateOAuthURL()` function has been updated to:

```typescript
export const generateOAuthURL = async () => {
    // ... existing code ...
    
    // Generate PKCE parameters
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    
    // Store code verifier for token exchange
    storeCodeVerifier(codeVerifier);
    
    // Build OAuth URL with PKCE parameters
    const oauthUrl = `${hostname}auth?response_type=code&client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUrl)}&state=${csrfToken}&code_challenge=${codeChallenge}&code_challenge_method=S256`;
    
    return oauthUrl;
};
```

**Key Changes:**
- Function is now `async` (returns Promise)
- Generates code verifier and code challenge
- Stores code verifier in sessionStorage
- Adds `code_challenge` and `code_challenge_method=S256` to OAuth URL

### 3. Token Exchange Service (oauth-token-exchange.service.ts)

The `exchangeCodeForToken()` method has been updated to:

```typescript
static async exchangeCodeForToken(code: string): Promise<TokenExchangeResponse> {
    // Retrieve the PKCE code verifier from session storage
    const codeVerifier = getCodeVerifier();
    
    if (!codeVerifier) {
        return {
            error: 'invalid_request',
            error_description: 'PKCE code verifier not found or expired.',
        };
    }
    
    // Include code_verifier in token exchange request
    const requestBody = new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        client_id: clientId,
        redirect_uri: redirectUrl,
        code_verifier: codeVerifier, // PKCE verification
    });
    
    // ... make request ...
    
    // Clear code verifier after successful exchange
    if (data.access_token) {
        clearCodeVerifier();
    }
}
```

**Key Changes:**
- Retrieves code verifier from sessionStorage
- Validates code verifier exists and hasn't expired
- Includes `code_verifier` in token exchange request body
- Clears code verifier after successful token exchange

### 4. Component Updates

#### header.tsx
```typescript
const handleLogin = useCallback(async () => {
    setIsAuthorizing(true);
    const oauthUrl = await generateOAuthURL(); // Now async
    if (oauthUrl) {
        window.location.replace(oauthUrl);
    }
}, [setIsAuthorizing]);
```

#### main.tsx
```typescript
const handleLoginGeneration = async () => {
    const oauthUrl = await generateOAuthURL(); // Now async
    if (oauthUrl) {
        // ... redirect logic ...
    }
};
```

## Security Benefits

1. **Authorization Code Interception Protection**: Even if an attacker intercepts the authorization code, they cannot exchange it for tokens without the code verifier
2. **No Client Secret Required**: PKCE allows public clients (like SPAs) to use OAuth securely without storing client secrets
3. **Replay Attack Prevention**: Code verifiers are single-use and expire after 10 minutes
4. **CSRF Protection**: Combined with existing CSRF token in the `state` parameter

## Flow Diagram

```
1. User clicks "Login"
   ↓
2. Generate code_verifier (random string)
   ↓
3. Generate code_challenge = SHA256(code_verifier)
   ↓
4. Store code_verifier in sessionStorage
   ↓
5. Redirect to OAuth server with code_challenge
   ↓
6. User authenticates
   ↓
7. OAuth server redirects back with authorization code
   ↓
8. Retrieve code_verifier from sessionStorage
   ↓
9. Exchange code + code_verifier for access token
   ↓
10. OAuth server verifies: SHA256(code_verifier) === stored code_challenge
    ↓
11. If valid, return access token
    ↓
12. Clear code_verifier from sessionStorage
```

## SessionStorage Keys

- `oauth_code_verifier`: The PKCE code verifier
- `oauth_code_verifier_timestamp`: Timestamp for expiration tracking
- `oauth_csrf_token`: CSRF protection token (existing)
- `oauth_csrf_token_timestamp`: CSRF token timestamp (existing)
- `auth_info`: JSON object containing authentication information

### auth_info Structure

```typescript
{
  "access_token": "ory_at_...",
  "token_type": "bearer",
  "expires_in": 2591999,
  "expires_at": 1738567890123, // Timestamp when token expires
  "scope": "",
  "refresh_token": "ory_rt_..." // Optional
}
```

## Expiration

Both PKCE code verifier and CSRF token expire after **10 minutes** (600,000 milliseconds).

## Helper Methods

The `OAuthTokenExchangeService` class provides several helper methods:

### `getAuthInfo(): AuthInfo | null`
Retrieves the stored authentication info from sessionStorage. Returns null if not found or expired.

### `clearAuthInfo(): void`
Clears the authentication info from sessionStorage.

### `isAuthenticated(): boolean`
Checks if the user is authenticated (has a valid, non-expired access token).

### `getAccessToken(): string | null`
Returns the current access token or null if not authenticated.

## Testing

To test the PKCE implementation:

1. Click the login button
2. Check sessionStorage for `oauth_code_verifier`
3. Verify the OAuth URL contains `code_challenge` and `code_challenge_method=S256`
4. Complete the OAuth flow
5. Verify the token exchange request includes `code_verifier`
6. Confirm `oauth_code_verifier` is cleared after successful exchange
7. Check sessionStorage for `auth_info` object with token details
8. Verify `expires_at` timestamp is set correctly

## Browser Compatibility

PKCE implementation uses:
- `crypto.getRandomValues()` - Supported in all modern browsers
- `crypto.subtle.digest()` - Supported in all modern browsers (requires HTTPS in production)
- `TextEncoder` - Supported in all modern browsers

## References

- [RFC 7636 - Proof Key for Code Exchange](https://tools.ietf.org/html/rfc7636)
- [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics)
